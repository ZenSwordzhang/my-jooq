## UML 类图

### 参考链接
* [参考链接](https://juejin.im/post/6844903795017646094)
* [uml_tutorial](https://www.w3cschool.cn/uml_tutorial/)

### 介绍
* 1997年，OMG 组织（Object Management Group对象管理组织）发布了统一建模语言（Unified Modeling Language，UML）
* UML 是一种编制软蓝图的标准化语言，它的目标之一就是为开发团队提供标准通用的设计语言来开发和构建计算机应用
* UML 提出了一套 IT 专业人员期待多年的统一的标准建模符号
* 通过使用UML，这些人员能够阅读和交流系统架构和设计规划
* UML支持面向对象的技术，能够准确的方便地表达面向对像的概念，体现面向对象的分析和设计风格.

### UML的模型构成
* 事物(Things)：UML模型中最基本的构成元素，是具有代表性的成分的抽象
* 关系(Relationships)：关系把事物紧密联系在一起
* 图(Diagrams )：图是事物和关系的可视化表示

### 主要模型
* 功能模型：从用户的角度展示系统的功能
    * 包括用例图
* 对象模型：采用对象、属性、操作、关联等概念展示系统的结构和基础
    * 包括类别图、对象图
* 动态模型：展现系统的内部行为
    * 包括序列图，活动图，状态图

### UML的特点
* 面向对象
* 可视化，表达能力强
* 独立于过程
* 独立于程序设计
* 容易掌握使用 

### UML2.2中一共定义了14种图示

#### 结构性图形（Structure diagrams）：强调的是系统式的建模：
* 静态图（static diagram)：包括类图、对象图、包图
* 实现图（implementation diagram）：包括组件图、部署图
* 剖面图
* 复合结构图

#### 行为式图形（Behavior diagrams）：强调系统模型中触发的事件
* 活动图
* 状态图
* 用例图

#### 交互性图形（Interaction diagrams）：属于行为图形的子集合，强调系统模型中的资料流程
* 通信图
* 交互概述图
* 时序图
* 时间图


### 类之间的关系
* ![](../../docs/img/uml/uml-01.jpg)

#### 继承（generalization）
* 继承用一条带空心箭头的直接表示

#### 实现（realize）
* 实现关系用一条带空心箭头的虚线表示

#### 组合（composition）
* 与聚合关系一样，组合关系同样表示整体由部分构成的语义
    * 比如公司由多个部门组成，但组合关系是一种强依赖的特殊聚合关系
    * 如果整体不存在了，则部分也不存在了
    * 例如，公司不存在了，部门也将不存在了

#### 聚合（aggregation）
* 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义
    * 例如一个部门由多个员工组成
    * 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在
    * 例如，部门撤销了，人员不会消失，他们依然存在

#### 关联（association）
* 关联关系是用一条直线表示的
    * 它描述不同类的对象之间的结构关系，它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的
    * 它一般用来定义对象之间静态的、天然的结构， 所以，关联关系是一种“强关联”的关系
    * 比如，乘车人和车票之间就是一种关联关系，学生和学校就是一种关联关系，关联关系默认不强调方向，表示对象间相互知道
    * 如果特别强调方向，使用直线带箭头

#### 依赖（dependency）
* 依赖关系是用一套带箭头的虚线表示的
    * 如A依赖于B，他描述一个对象在运行期间会用到另一个对象的关系
    * 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化
    * 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生

## 六大原则

### 开闭原则
* 一个软件实体应当对扩展开放，对修改关闭
    * 即软件实体应尽量在不修改原有代码的情况下进行扩展

### 里氏替换原则
* 所有引用基类对象的地方都能够透明地使用其子类的对象

### 依赖倒置原则
* 抽象不应该依赖于具体类，具体类应当依赖于抽象
    * 换言之，要针对接口编程，而不是针对实现编程

### 单一职责原则
* 一个类只负责一个功能领域中的相应职责
    * 或者可以定义为：就一个类而言，应该只有一个引起它变化的原因

### 迪米特法则
* 一个软件实体应当尽可能少地与其他实体发生相互作用

### 接口分离原则
* 使用多个专门的接口，而不使用单一的总接口
    * 即客户端不应该依赖那些它不需要的接口


## 模式分类

### 创建型(Creational)
* 1.简单工厂模式（Simple Factory Pattern）
* 2.工厂方法模式（Factory Method Pattern）
* 3.抽象工厂模式（Abstract Factory Pattern）
* 4.单例模式（Singleton Pattern）
* 5.建造者模式（Builder Pattern）
* 6.原型模式（Prototype Pattern）



### 结构型(Structural)
* 1.外观模式(Facade Pattern)
* 2.适配器模式(Adapter Pattern)
* 3.桥接模式(Bridge Pattern)
* 4.代理模式(Proxy Pattern)
* 5.装饰器模式（Decorator Pattern）
* 6.享元模式（Flyweight Pattern）



### 行为型(Behavioral)
* 1.责任链模式（Chain of Responsibility Pattern）
* 2.命令模式（Command Pattern）
* 3.解释器模式（Interpreter Pattern）
* 4.迭代器模式（Iterator Pattern）
* 5.中介者模式（Mediator Pattern）
* 6.备忘录模式（Memento Pattern）
* 7.观察者模式（Observer Pattern）
* 8.状态模式（State Pattern）
* 9.策略模式（Strategy Pattern）
* 10.模板模式（Template Pattern）
* 11.访问者模式（Visitor Pattern）















